	 OPT	   MEX,CEX,NOPCS
******************************************************************************
*									     *
*	 MODULE:   EXEC ( REAL-TIME & BACK-GROUND EXECUTIVE )		     *
*									     *
*	 VERSION   1.0	 02/07/83      D.R. TRIPP			     *
*									     *
*	 VERSION:  2.0	 11/30/83      D.R. TRIPP			     *
*									     *
******************************************************************************
	 PAGE
**********************************************************************
*								     *
*	 EXTERNAL LINKAGE INFORMATION				     *
*								     *
**********************************************************************
	 XDEF	   BGEXEC	       BACK-GROUND EXEC
	 XDEF	   BGTERM	       BACK-GROUND TERMINATE
	 XDEF	   BGRSUM	       BACK-GROUND RESUME
	 XDEF	   BGHOLD	       BACK-GROUND HOLD
	 XDEF	   BGWAIT	       BACK-GROUND WAIT
*
	 XDEF	   RTINIT	       REAL-TIME INITIALIZER
	 XDEF	   RTINT6	       REAL-TIME INTERRUPT RECEIVER (TIMER)
	 XREF	   IVINIT	       INTERRUPT VECTOR INITIALIZER
	 XDEF	   RTEXEC	       REAL-TIME EXEC
	 XDEF	   RTEND	       LAST REAL-TIME MODULE
	 XDEF	   RTRET	       RETURN POINT OF REAL-TIME MODS
	 XDEF	   RTMODCTL	       REAL-TIME MODULE CONTROL
	 XDEF	   RTMTC	       REAL-TIME MODULE TIMER CONTROL
	 XREF	   RTDEBUG	       REAL-TIME DEBUG MODULE
	 XREF	   RTLIST	       START OF JUMP LIST
	 XREF	   RTNAME	       MODULE NAME LIST
	 XREF	   RTNUMBER	       NUMBER OF REAL-TIME MODULES
*
	 XDEF	   LPOOL	       LOCAL DATA POOL
	 XDEF	   GPOOL	       GLOBAL DATA POOL
*
	 XREF	   LCPU 	       CPU UNIQUE DATA
	 XREF	   TASKDATA	       BACK-GROUND INITIAL DATA
*
	 XDEF	   STCB 	       TCB ADDRESS ACTIVE TASK
	 XDEF	   STCB1	       TCB ADDRESS FIRST IN CHAIN
	 XDEF	   STCBN	       TCB ADDRESS LAST  IN CHAIN
	 XDEF	   STCBNUM	       NUMBER OF TCB'S IN CHAIN
	 XDEF	   STCBID	       ACTIVE TASK ID NUMBER
*
	 XDEF	   HEAP 	       HEAP STORAGE AREA
*
	 XDEF	   SSTACK	       SYSTEM STACK
	 XDEF	   USTACK	       USER STACK
*
	 XDEF	   EXCEPT1	       ADDRESS ERROR EXCEPTION
	 XDEF	   EXCEPT0	       BUS ERROR EXCEPTION
	 XDEF	   EXCEPT2	       DIVIDE BY ZERO EXCEPTION
	 XDEF	   EXCEPT3	       PRIV. VIOLATION EXCEPTION

	 XDEF	   SMODTOUT	       MODULE TIMEOUT COUNTERS
	 XDEF	   SBMODRUN	       MODULE ENABLE FLAGS
	 XDEF	   TFRAME	       TOTAL FRAME TIME (MICROSEC)
	 PAGE
**********************************************************************
*								     *
*	 RAM DATA FOR EXEC					     *
*								     *
**********************************************************************
	 SECTION.S 1		       SECTION ONE (LOW RAM)
SLOAD	 DS.B	   1		       LOAD UP AND RUNNING FLAG
SRTEXEC  DS.B	   1		       REAL-TIME EXEC ACTIVE FLAG
SBGEXEC  DS.B	   1		       BACK-GROUND EXEC ACTIVE FLAG
SFRAME	 DS.B	   1		       CURENT FRAME NUMBER 0-7
SMODULE  DS.B	   1		       CURENT MODULE NUMBER 0-N
SBFIRST  DS.B	   1		       FIRST FRAME FLAG FOR RTEXEC
SBNOTIME DS.B	   1		       NO TIME FLAG
SBTIME	 DS.B	   1		       MODULE TIMER SYSTEM ENABLE FLAG
SBMODRUN DS.B	   24		       MODULE RUN ENABLE FLAGS
SOUTBUFF DS.B	   32		       OUTPUT BUFFER FOR EXEC MESSAGES
*
SCURMASK DS.W	   1		       CURRENT FRAME MASK (LOW BYTE NOT USED)
*
STCBID	 DS.W	   1		       ACTIVE TCB ID NUMBER
STCBNUM  DS.W	   1		       NUMBER OF TCB'S IN CHAIN
*
S400I	 DS.B	   1		       MVME 400 INSTALLED FLAG
S410I	 DS.B	   1		       MVME 410 INSTALLED FLAG
*
STEMP	 DS.L	   1		       TEMPOARY SAVE AREA
*
SCYCLE	 DS.L	   1		       CURENT CYCLE NUMBER
*
SMODADR  DS.L	   1		       POINTER TO JUMP LIST TABLE
SRUNADR  DS.L	   1		       POINTER TO RUN ENABLE FLAG TABLE
*
STCB	 DS.L	   1		       TCB ADDRESS OF ACTIVE TASK
STCB1	 DS.L	   1		       TCB ADDRESS OF FIRST IN CHAIN
STCBN	 DS.L	   1		       TCB ADDRESS OF LAST  IN CHAIN
*
SADDEX	 DS.L	   1		       NORMAL ADDRESS EXCEPTION VECTOR
SBUSEX	 DS.L	   1		       NORMAL BUS ERROR EXCEPTION VECTOR
SPVEX	 DS.L	   1		       NORMAL PRIV. VIOLATION EXCEPTION
SDZEX	 DS.L	   1		       NORMAL DIVIDE BY ZERO EXCEPTION
*
SPCATERR DS.L	   1		       SAVE PC FOR TIME-OUT
STIMEOUT DS.L	   1		       TOTAL TIMEOUT COUNTER
SMODTOUT DS.L	   24		       MODULE TIME OUT COUNTS
*
STIMAD	 DS.L	   1		       TIMMER ADDRESS
**********************************************************************
*								     *
*	 HEAP ALLOCATION DATA AREA				     *
*								     *
**********************************************************************
SSTACK	 DS.L	   1		       ADDRESS OF SYSTEM STACK (END)
USTACK	 DS.L	   1		       ADDRESS OF USER STACK (END)
LPOOL	 DS.L	   1		       ADDRESS OF LOCAL DATA POOL
HEAP	 DS.L	   1		       ADDRESS OF HEAP DATA AREA
	 PAGE
**********************************************************************
*								     *
*	 DEBUG DATA-POOL SYMBOLS				     *
*								     *
**********************************************************************
~i	 INCLUDE   DSYM.SA
DSEG	  EQU	$00000F00 L 001 L H   DEBUG DATA SEGMENT ADDRESS
DBUFF	  EQU	$00000F04 B 080 L H   DEBUG INPUT BUFFER
DBUFFPTR  EQU	$00000F54 L 001 L H   DEBUG INPUT BUFFER POINTER
DBUFFCNT  EQU	$00000F58 B 001 L H   DEBUG INPUT BUFFER COUNT
DBUFFLNE  EQU	$00000F59 B 001 L H   DEBUG INPUT BUFFER LINE COMPLETE FLAG
DBUFFCHG  EQU	$00000F5A B 001 L H   DEBUG INPUT BUFFER CHANGE FLAG
D400I	  EQU	$00000F5B B 001 L H   DEBUG MVME400 INSTALLED FLAG
DLIST	  EQU	$00000F5C L 128 L H   DEBUG DISPLAY LIST
DCOUNT	  EQU	$0000115C W 001 L H   DEBUG DISPLAY LIST COUNT
DSPARE2   EQU	$0000115E W 001 L H   DEBUG SPARE WORD
TFRAME	  EQU	$00001160 L 001 L D   FRAME TIME ACTUAL
TFRAMEA   EQU	$00001164 L 001 L D   FRAME TIME AVERAGE
TFRAMEW   EQU	$00001168 L 001 L D   FRAME TIME WORST
TMODULE   EQU	$0000116C W 016 L D   MODULE TIMES ACTUAL
TMODULEA  EQU	$0000118C W 016 L D   MODULE TIMES AVERAGE
TMODULEW  EQU	$000011AC W 016 L D   MODULE TIMES WORST
DSPARE	  EQU	$000011CC L 032 L H   DEBUG SPARE LONG WORDS
	 PAGE
**********************************************************************
*								     *
*	 TASK CONTEXT BLOCK (TCB) OFFSET EQUATES		     *
*								     *
**********************************************************************
~i	 INCLUDE   TCBSYM.SA
	 OFFSET    0
TCBNAME  DS.B	   08	    TASK NAME
TCBDS	 DS.L	   01	    TASK DATA SEGMENT POINTER
TCBCS	 DS.L	   01	    TASK CODE SEGMENT POINTER
TCBSS	 DS.L	   01	    TASK STACK SEGMENT POINTER
TCBID	 DS.W	   01	    TASK ID NUMBER
TCBDSL	 DS.W	   01	    TASK DATA SEGMENT LENGTH
TCBCSL	 DS.W	   01	    TASK CODE SEGMENT LENGTH
TCBSSL	 DS.W	   01	    TASK STACK SEGMENT LENGTH
TCBENTRY DS.L	   01	    TASK ENTRY POINT
TCBEXEP  DS.L	   01	    TASK EXECPTION ENTRY POINT
TCBHOLD  DS.B	   01	    TASK HOLD FLAG
TCBRUN	 DS.B	   01	    TASK RUN FLAG
TCBERR	 DS.B	   01	    TASK ERROR FLAG
TCBWAIT  DS.B	   01	    TASK WAIT FLAG
TCBEX	 DS.B	   01	    TASK EXCEPTION ENTRY FLAG
	 DS.B	   01	    SPARE
TCBPRI	 DS.W	   01	    TASK PRIORITY CODE
TCBSR	 DS.W	   01	    TASK STATUS REGISTER
TCBPC	 DS.L	   01	    TASK PROGRAM COUNTER
TCBREGS  DS.L	   15	    TASK REGISTER D0-D7/A0-A6
TCBUSP	 DS.L	   01	    TASK STACK POINTER (A7)
TCBIR	 DS.W	   01	    TASK INSTUCTION REGISTER
TCBAI	 DS.W	   01	    TASK ACCESS INFORMATION
TCBVN	 DS.W	   01	    TASK VECTOR NUMBER
*	 DS.W	   01	    SPARE
TCBAA	 DS.L	   01	    TASK ERROR ACCESS ADDRESS
TCBLINK  DS.L	   01	    LINK TO NEXT TCB
	 PAGE
**********************************************************************
*								     *
*	 TASK DATA BLOCK (TDB) OFFSET EQUATES			     *
*								     *
**********************************************************************
~i	 INCLUDE   TDBSYM.SA
	 OFFSET    0
TDBNAME  DS.B	   08	    TASK NAME
TDBEP	 DS.L	   01	    TASK ENTRY POINT
TDBCS	 DS.L	   01	    TASK CODE SEGMENT POINTER
TDBCSL	 DS.W	   01	    TASK CODE SEGMENT LENGTH
TDBDSL	 DS.W	   01	    TASK DATA SEGMENT LENGTH
TDBSSL	 DS.W	   01	    TASK STACK SEGMENT LENGTH
TDBPRI	 DS.W	   01	    TASK PRIORITY CODE
TDBFLAG1 DS.B	   01	    TDB FLAG BITS
TDBFLAG2 DS.B	   01	    TDB FLAG BITS
TDBFLAG3 DS.B	   01	    TDB FLAG BITS
TDBFLAG4 DS.B	   01	    TDB FLAG BITS
TDBERROR DS.L	   01	    TASK ERROR ENTRY POINT
TDBLINK  DS.L	   01	    LINK TO NEXT TDB
	 PAGE
**********************************************************************
*								     *
*	 HEAP STORAGE AREA					     *
*								     *
**********************************************************************
	 SECTION.S 2
INITHEAP DS.B	   1024*12	       12K OF INITIAL HEAP
HEAPEND  EQU	   *		       HEAP END
**********************************************************************
*								     *
*	 GLOBAL DATA POOL					     *
*								     *
**********************************************************************
	 SECTION   3
GPOOL	 DS.L	   256		       1K OF GLOBAL DATA POOL
GPOOLEND EQU	   *		       GLOBAL DATA POOL END
	 PAGE
**********************************************************************
*								     *
*	 LOCAL CONSTANTS FOR REAL-TIME & BACK-GROUND EXEC'S          *
*								     *
**********************************************************************
	 SECTION   12
*
MTIMER	 EQU	   $F0000	       MODULE TIMER #1
*
PNT8HX	 EQU	   $F03A72	       PNT8HX ENTRY POINT
HEX2DEC  EQU	   $F032B4	       HEX2DEC ENTRY POINT
OUT1CR	 EQU	   $F03CC0	       OUT1CR ENTRY POINT
*
CR2	 EQU	   $FE8013	       CONTROL REG. 2
CR13	 EQU	   $FE8011	       CONTROL REG. 1/3
BRH	 EQU	   $FE8015	       BUFFER REG. HIGH BYTE
BR3L	 EQU	   $FE801F	       TIMER #3 LATCH LOW BYTE
RT3C	 EQU	   $FE801D	       TIMER #3 COUNTER REG.
*
ACIAC	 EQU	   $FE8001	       ACIA CONTROL & STATUS REGISTERS
ACIAD	 EQU	   $FE8003	       ACIA DATA REGISTERS
*
MSR	 EQU	   $FE8031	       MODULE STATUS REGISTER
*
NECA	 EQU	   $FE61C9	       NEC SERIAL PORT A
NECB	 EQU	   $FE61CB	       NEC SERIAL PORT B
*
**********************************************************************
*								     *
*	 RTINT6    REAL-TIME INTERRUPT RECEIVER 		     *
*								     *
**********************************************************************
RTINT6	 EQU	   *
	 MOVE.W    #$2700,SR	       MASK ALL INTERRUPTS
	 TST.B	   SLOAD	       TEST LOAD UP & RUNNING FLAG
	 BEQ.S	   QUIT6	       QUIT IF NO LOAD RUNNING
	 TST.B	   SRTEXEC	       TEST RTEXEC FLAG
	 BEQ.S	   TESTBG	       IF NOT GO AND TEST FOR B. G.
	 ADDQ.L    #1,STIMEOUT	       ADD ONE FOR TIME OUT COUNT
	 MOVE.L    #SMODTOUT,A0        LOAD ADDRESS
	 CLR.L	   D0		       CLEAR D0
	 MOVE.B    SMODULE,D0	       LOAD MODULE NUMBER
	 LSL.L	   #2,D0	       MULTIPLY BY 4
	 ADD.L	   D0,A0	       CALCULATE OFFSET
	 ADDQ.L    #1,(A0)	       ADD TO MODULE TIME OUT COUNT
	 CLR.B	   SRTEXEC	       CLEAR RTEXEC FLAG
	 MOVE.L    2(A7),D0	       LOAD RETURN PC
	 MOVE.L    D0,SPCATERR	       SAVE PC FOR INSPECTION
	 CMP.L	   #RTRET,D0	       DID IT INTERRUPT AFTER A TRAP
	 BNE.S	   QUIT6T	       IF NOT CONTINUE AS NORMAL
	 ADDQ.L    #6,A7	       CLEAR TRAP PC & SR FROM STACK
	 BRA.S	   QUIT6T	       GO AND CLEAR INTER. PC & SR FROM STK.
TESTBG	 TST.B	   SBGEXEC	       TEST BGEXEC FLAG
	 BEQ.S	   QUIT6	       BRANCH IF FALSE
	 MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 INTO TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7),TCBSR(A0)      SAVE SR IN TCB
	 MOVE.L    2(A7),TCBPC(A0)     SAVE PC IN TCB
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 ST.B	   TCBHOLD(A0)	       SET HOLD FLAG TO TRUE
	 CLR.B	   SBGEXEC	       SET BACK-GROUND FLAG OFF
QUIT6	 ADDQ.L    #6,A7	       CLEAR RETURN INFORMATION
QUIT6A	 TST.B	   CR2		       CLEAR INTERUPT
	 TST.B	   RT3C 	       CLEAR INTERUPT
	 MOVE.W    #$2500,SR	       ALLOW PTM INTERRUPT
	 BRA	   RTEXEC	       GOTO RTEXEC
QUIT6T	 ADD.L	   #14,A7	       CLEAR DATA ON STACK & ADDRESSES
	 CLR.B	   SBFIRST	       RESET TO FIRST FRAME
	 CLR.B	   SMODULE	       RESET TO FIRST MODULE
	 BRA.S	   QUIT6A	       DO THE REST
	 PAGE
**********************************************************************
*								     *
*	 RTINIT    REAL-TIME INITIALIZER			     *
*								     *
**********************************************************************
RTINIT	 EQU	   *
	 MOVE.W    #$2700,SR	       LOAD SR

*
	 MOVE.L    #LCPU,A1	       LOAD EXEC BLOCK
	 MOVE.L    16(A1),A0	       LOAD START OF MEMORY
CLRMEM	 CLR.L	   (A0)+	       CLEAR MEMORY
	 CMP.L	   20(A1),A0	       TEST FOR END
	 BNE.S	   CLRMEM	       CLEAR SOME MORE
*
	 MOVE.L    #MTIMER,A0	       LOAD ADDRESS OF TIMER
	 MOVEQ.L   #0,D0	       CLEAR A2
	 MOVE.B    8(A1),D0	       LOAD CPU NUMBER
	 SUB.B	   #1,D0	       ADJUST CPU NUMBER
	 LSL.L	   #8,D0	       SHIFT 8
	 LSL.L	   #4,D0	       SHIFT 4
	 ADD.L	   D0,A0	       ADD OFFSET TO TIMER ADDRESS
	 MOVE.L    A0,STIMAD	       STORE TIMER ADDRESS
*
	 LEA	   INITHEAP,A1	       LOAD START OF INITIAL HEAP
*
	 LEA	   MSG1,A0	       LOAD ADDRESS OF MESSAGE 1
	 MOVE.L    A1,D0	       LOAD SSTACK ADDRESS
	 JSR	   DISPADR	       DISPLAY MESSAGE
*
	 ADD.L	   #1024,A1	       ADD 1K FOR SSTACK
	 MOVE.L    A1,SSTACK	       SAVE END ADDRESS+1 FOR SSTACK
*
	 LEA	   MSG2,A0	       LOAD ADDRESS OF MESSAGE 2
	 MOVE.L    A1,D0	       LOAD USTACK ADDRESS
	 JSR	   DISPADR	       DISPLAY MESSAGE
*
	 ADD.L	   #512,A1	       ADD 512B FOR USTACK
	 MOVE.L    A1,USTACK	       SAVE END ADDRESS+1 FOR USTACK
*
	 LEA	   MSG3,A0	       LOAD ADDRESS OF MESSAGE 3
	 MOVE.L    A1,D0	       LOAD LPOOL ADDRESS
	 JSR	   DISPADR	       DISPLAY MESSAGE
*
	 MOVE.L    A1,LPOOL	       SAVE START ADDRESS OF LPOOL
	 ADD.L	   #1024*6,A1	       ADD 6K FOR LPOOL
*
	 MOVE.L    A1,HEAP	       SAVE START ADDRESS WITH REMANDER
*
	 MOVE.L    SSTACK,A7	       LOAD ADDRESS OF SYSTEM STACK
	 MOVE.L    USTACK,A6	       LOAD ADDRESS OF USER STACK
	 MOVE.L    A6,USP	       LOAD USER STACK
*
	 MOVE.L    #RTINT6,$78	       LOAD AUTO VECTOR #6
*
	 BTST.B    #4,MSR	       TEST SSB0
	 SNE.B	   S400I	       SET IF SSB0 = 1 (MVME400)
	 SNE.B	   D400I	       SET IF SSB0 = 1 (MVME400)
	 BTST.B    #5,MSR	       TEST SSB1
	 SNE.B	   S410I	       SET IF SSB1 = 1 (MVME410)
*
	 JSR	   IVINIT	       INITIALIZE INTERRUPT VECTORS
*
	 MOVE.L    #RTRET,$80	       LOAD TRAP #0 VECTOR
	 MOVE.L    #BGHOLD,$84	       LOAD TRAP #1 VECTOR
	 MOVE.L    #BGWAIT,$88	       LOAD TRAP #2 VECTOR
	 MOVE.L    #BGTERM,$8C	       LOAD TRAP #3 VECTOR
	 MOVE.L    #BGRSUM,$90	       LOAD TRAP #4 VECTOR
	 MOVE.L    #RTINIT,$94	       LOAD TRAP #5 VECTOR
	 MOVE.L    #RTMODCTL,$98       LOAD TRAP #6 VECTOR
	 MOVE.L    #RTMTC,$9C	       LOAD TRAP #7 VECTOR
*
	 MOVE.L    $08,SBUSEX	       SAVE BUS ERROR EXCEPTION
	 MOVE.L    #EXCEPT0,$08        LOAD BUS ERROR EXCEPTION VECTOR
*
	 MOVE.L    $0C,SADDEX	       SAVE ADDRESS EXCEPTION
	 MOVE.L    #EXCEPT1,$0C        LOAD ADDRESS EXCEPTION VECTOR
*
	 MOVE.L    $14,SDZEX	       SAVE DIVIDE BY ZERO EXCEPTION
	 MOVE.L    #EXCEPT2,$14        LOAD ADDRESS EXCEPTION VECTOR
*
	 MOVE.L    $20,SPVEX	       SAVE PRIV. VIOLATION EXCEPTION
	 MOVE.L    #EXCEPT3,$20        LOAD ADDRESS EXCEPTION VECTOR
*
	 MOVE.B    #1,CR2	       ENABLE A WRITE TO TIMER #1
	 MOVE.B    #1,CR13	       HOLD TIMERS
	 CLR.B	   CR2		       ENABLE A WRITE TO TIMER #3
	 MOVE.B    #$40,CR13	       EXT. CLOCK & INTERRUPT
	 MOVE.B    #$1E,BRH	       LOAD MSB
	 MOVE.B    #$00,BR3L	       LOAD LSB INTO TIMER #3 LATCHES
	 MOVE.B    #$01,CR2	       ENABLE A WRITE TO TIMER #1
*
	 MOVE.L    #TASKDATA,A6        LOAD ADDRESS OF FIRST TDB
*
	 MOVE.L    TDBEP(A6),A1        LOAD ENTRY POINT
	 MOVE.L    TDBCS(A6),A2        LOAD CODE SEGMENT POINTER
	 MOVE.W    TDBCSL(A6),D1       LOAD CODE SEGMENT LENGTH
	 MOVE.W    TDBDSL(A6),D2       LOAD DATA SEGMENT LENGTH
	 MOVE.W    TDBSSL(A6),D3       LOAD STACK SEGMENT LENGTH
	 MOVE.W    TDBPRI(A6),D4       LOAD TASK PRIORITY CODE
	 MOVE.L    TDBERROR(A6),D5     LOAD TASK ERROR ENTRY POINT
	 MOVE.L    A6,A0	       COPY POINTER
	 JSR	   BUILDTCB	       BUILD A TCB
	 TST.B	   D0		       TEST RETURN CODE
	 BNE	   TCBAERR	       BRANCH IF TCB ALLOCATION ERROR
	 MOVE.L    A0,D0	       LOAD ADDRESS TO DISPLAY
	 JSR	   DISPADR	       DISPLAY TCB ADDRESS
*
	 BTST	   #0,TDBFLAG1(A6)     TEST SET RUN FLAG OPTION BIT
	 BEQ.S	   FTCB1	       BRANCH IF NOT SET
	 ST.B	   TCBRUN(A0)	       SET RUN FLAG
FTCB1	 BTST	   #1,TDBFLAG1(A6)     TEST EXECPTION ENTRY OPTION BIT
	 BEQ.S	   FTCB2	       BRANCH IF NOT SET
	 ST.B	   TCBEX(A0)	       SET EXECPTION ENTRY FLAG
FTCB2	 MOVE.L    A0,STCB1	       SET FIRST TCB
*
TDBLOOP  MOVE.L    TDBLINK(A6),A6      LOAD LINK TO NEXT TDB
	 CMP.L	   #0,A6	       TEST FOR NULL POINTER
	 BEQ.S	   ENDTDB	       BRANCH IF NULL POINTER FOUND
*
	 MOVE.L    TDBEP(A6),A1        LOAD ENTRY POINT
	 MOVE.L    TDBCS(A6),A2        LOAD CODE SEGMENT POINTER
	 MOVE.W    TDBCSL(A6),D1       LOAD CODE SEGMENT LENGTH
	 MOVE.W    TDBDSL(A6),D2       LOAD DATA SEGMENT LENGTH
	 MOVE.W    TDBSSL(A6),D3       LOAD STACK SEGMENT LENGTH
	 MOVE.W    TDBPRI(A6),D4       LOAD TASK PRIORITY CODE
	 MOVE.L    TDBERROR(A6),D5     LOAD TASK ERROR ENTRY POINT
	 MOVE.L    A0,A5	       SAVE LAST TCB POINTER
	 MOVE.L    A6,A0	       COPY POINTER
	 JSR	   BUILDTCB	       BUILD A TCB
	 TST.B	   D0		       TEST RETURN CODE
	 BNE.S	   TCBAERR	       BRANCH IF TCB ALLOCATION ERROR
	 MOVE.L    A0,D0	       LOAD ADDRESS TO DISPLAY
	 JSR	   DISPADR	       DISPLAY TCB ADDRESS
*
	 BTST	   #0,TDBFLAG1(A6)     TEST SET RUN FLAG OPTION BIT
	 BEQ.S	   NTCB1	       BRANCH IF NOT SET
	 ST.B	   TCBRUN(A0)	       SET RUN FLAG
NTCB1	 BTST	   #1,TDBFLAG1(A6)     TEST EXCPTION ENTRY OPTION BIT
	 BEQ.S	   NTCB2	       BRANCH IF NOT SET
	 ST.B	   TCBEX(A0)	       SET EXCPTION ENTRY FLAG
*
NTCB2	 MOVE.L    A0,TCBLINK(A5)      LINK LAST TCB TO THIS TCB
	 BRA.S	   TDBLOOP	       LOOP UNTIL ALL TASK ARE CREATED
*
ENDTDB	 MOVE.L    A0,STCBN	       SET LAST TCB
	 MOVE.L    STCB1,TCBLINK(A0)   LINK LAST TCB TO FIRST TCB
*
	 MOVE.L    STCBN,STCB	       SET LAST TASK TO ACTIVE TASK
*
	 LEA	   MSG5,A0	       LOAD ADDRESS OF MESSAGE 5
	 MOVE.L    HEAP,D0	       LOAD HEAP ADDRESS
	 JSR	   DISPADR	       DISPLAY MESSAGE
*
	 ST.B	   SLOAD	       SET LOAD UP AND RUNNING FLAG
	 MOVE.W    #$2500,SR	       ALLOW PTM INTERRUPT
*
	 MOVE.W    #$8000,SCURMASK     LOAD FRAME MASK (FIRST FRAME)
*
	 CLR.B	   CR13 	       RELEASE TIMERS
*
RTX	 BRA.S	   RTX		       LOOP UNTIL INTERRUPT
*
TCBAERR  EQU	   *		       TCB ALLOCATION ERROR
	 LEA	   SOUTBUFF,A5	       LOAD ADDRESS OF OUTPUT BUFFER
	 MOVE.L    A5,A6	       COPY BUFFER POINTER
	 MOVE.L    #'TASK',(A6)+       LOAD MESSAGE
	 MOVE.L    #' ALL',(A6)+       LOAD MESSAGE
	 MOVE.L    #'OCAT',(A6)+       LOAD MESSAGE
	 MOVE.L    #'ION ',(A6)+       LOAD MESSAGE
	 MOVE.L    #'ERRO',(A6)+       LOAD MESSAGE
	 MOVE.L    #'R ( ',(A6)+       LOAD MESSAGE
	 MOVE.L    (A0),(A6)+	       LOAD TASK NAME
	 MOVE.L    4(A0),(A6)+	       LOAD TASK NAME
	 MOVE.W    #' )',(A6)+         LOAD MESSAGE
	 JSR	   OUT1CR	       OUTPUT LINE WITH CR/LF
TCBX	 BRA.S	   TCBX 	       LOOP FOREVER
*
	 DS.L	   0		       LONG WORD BOUNDARY
MSG1	 DC.B	   'SSTACK  '
MSG2	 DC.B	   'USTACK  '
MSG3	 DC.B	   'LPOOL   '
MSG5	 DC.B	   'HEAP    '
	 PAGE
**********************************************************************
*								     *
*	 BUILDTCB  BUILD TCB SUBROUTINE 			     *
*								     *
*		   INPUT:    A0 = POINTER TO 8 CHARACTER TASK NAME   *
*			     A1 = ENTRY POINT			     *
*			     A2 = CODE SEGMENT ADDRESS		     *
*			     D1 = CODE SEGMENT SIZE		     *
*			     D2 = DATA SEGMENT SIZE		     *
*			     D3 = STACK SEGMENT SIZE		     *
*			     D4 = PRIORITY CODE 		     *
*			     D5 = ERROR ENTRY POINT		     *
*								     *
*		   OUTPUT:   A0 = TCB ADDRESS			     *
*			     D0 = RETURN CODE (0=OK,1=ERROR)	     *
*								     *
**********************************************************************
TCBSIZE  EQU	   $80		       128 BYTES FOR EACH TCB
BUILDTCB EQU	   *
	 MOVE.L    #TCBSIZE,D0	       LOAD TCB SIZE
	 JSR	   GETMEM	       ALLOCATE MEMORY FOR A TCB
	 TST.B	   D0		       TEST RETURN CODE
	 BNE.S	   ERRTCB	       BRANCH IF TRUE
	 ADD.W	   #1,STCBNUM	       INCREMENT TCB NUMBER
	 MOVE.W    STCBNUM,TCBID(A3)   STORE TASK ID IN TCB
	 MOVE.W    D1,TCBCSL(A3)       STORE CODE SEGMENT SIZE IN TCB
	 MOVE.L    A2,TCBCS(A3)        STORE CODE SEGMENT ADDRESS IN TCB
	 MOVE.L    A1,TCBENTRY(A3)     STORE ENTRY POINT IN TCB
	 MOVE.W    D4,TCBPRI(A3)       STORE PRIORITY CODE IN TCB
	 MOVE.L    D5,TCBEXEP(A3)      STORE EXCEPTION ENTRY POINT IN TCB
	 MOVEQ.L   #7,D1	       LOAD LOOP COUNTER
	 MOVEQ.L   #0,D4	       LOAD INDEX
NMLOOP	 MOVE.B    (A0)+,TCBNAME(A3,D4.W)	 STORE NAME IN TCB
	 ADDQ.L    #1,D4	       INCREMENT INDEX
	 DBRA	   D1,NMLOOP	       LOOP 8 TIMES
	 MOVE.L    A3,A0	       COPY TCB ADDRESS
	 MOVE.W    D2,D0	       LOAD DATA SEGMENT SIZE
	 JSR	   GETMEM	       ALLOCATE DATA SEGMENT
	 TST.B	   D0		       TEST RETURN CODE
	 BNE.S	   ERRTCB	       BRANCH IF TRUE
	 MOVE.W    D3,TCBDSL(A0)       STORE DATA SEGMENT SIZE IN TCB
	 MOVE.L    A3,TCBDS(A0)        STORE DATA SEGMENT ADDRESS IN TCB
	 MOVE.W    D3,D0	       LOAD STACK SEGMENT SIZE
	 JSR	   GETMEM	       ALLOCATE STACK SEGMENT
	 TST.B	   D0		       TEST RETURN CODE
	 BNE.S	   ERRTCB	       BRANCH IF TRUE
	 MOVE.W    D3,TCBSSL(A0)       STORE STACK SEGMENT SIZE IN TCB
	 MOVE.L    A4,TCBSS(A0)        STORE STACK SEGMENT ADDRESS IN TCB
	 MOVEQ.L   #0,D0	       CLEAR RETURN CODE
	 RTS
ERRTCB	 MOVEQ.L   #1,D0	       SET RETURN CODE (ERROR)
	 RTS
	 PAGE
**********************************************************************
*								     *
*	 DISPADR   DISPLAY TEXT AND ADDRESS ON CONSOLE		     *
*								     *
*		   INPUT:  A0=ADDRESS OF TEXT (8 CHRAACTERS)	     *
*			   D0=DATA TO BE DISPLAYED (HEX LONG)	     *
*								     *
**********************************************************************
DISPADR  EQU	   *
	 MOVEM.L   A5/A6,-(A7)	       SAVE A5/A6
	 LEA	   SOUTBUFF,A5	       LOAD ADDRESS OF OUTPUT BUFFER
	 MOVE.L    A5,A6	       COPY BUFFER POINTER
	 MOVE.L    (A0),(A6)+	       LOAD TASK NAME PART 1
	 MOVE.L    4(A0),(A6)+	       LOAD TASK NAME PART 2
	 MOVE.B    #' ',(A6)+          LOAD A SPACE
	 JSR	   PNT8HX	       CONVERT TO HEX
	 JSR	   OUT1CR	       OUTPUT LINE WITH CR/LF
	 MOVEM.L   (A7)+,A5/A6	       RESTORE A5/A6
	 RTS			       RETURN
	 PAGE
**********************************************************************
*								     *
*	 GETMEM    HEAP MEMORY ALLOCATION SUBROUTINE		     *
*								     *
*		   INPUT:  D0=NUMBER OF BYTES TO ALLOCATE	     *
*								     *
*		   OUTPUT: A3=START ADDRESS, A4=END ADDRESS+1	     *
*			   D0=RETURN CODE (0=OK,1=ERROR)	     *
*								     *
**********************************************************************
GETMEM	 EQU	   *
	 MOVE.L    HEAP,A3	       LOAD ADDRESS OF HEAP
	 MOVE.L    A3,A4	       COPY ADDRESS
	 ADD.L	   D0,A4	       ADD NUMBER OF BYTES
	 CMP.L	   #HEAPEND,A4	       TEST FOR END OF HEAP
	 BGE.S	   GETERR1	       BRANCH IF BEYOND END OF HEAP
	 MOVE.L    A4,HEAP	       STORE NEW HEAP ADDRESS
	 SF.B	   D0		       SET RETURN CODE FALSE
	 RTS			       RETURN
GETERR1  ST.B	   D0		       SET RETURN CODE TRUE
	 RTS			       RETURN
	 PAGE
**********************************************************************
*								     *
*	 EXCEPT0   BUS ERROR EXCEPTION				     *
*								     *
**********************************************************************
EXCEPT0  EQU	   *
	 MOVE.W    #$2700,SR	       MASK ALL INTERRUPTS
	 TST.B	   SRTEXEC	       TEST RTEXEC FLAG
	 BEQ.S	   TSTBG0	       IF NOT GO AND TEST FOR B. G.
	 MOVE.L    SBUSEX,-(A7)        PUSH REAL VECTOR ADDRESS
	 RTS			       GOTO ADDRESS ON STACK
*
TSTBG0	 TST.B	   SBGEXEC	       TEST BGEXEC FLAG
	 BNE.S	   BGAEXP0	       BRANCH IF TRUE
	 MOVE.L    SBUSEX,-(A7)        PUSH REAL VECTOR ADDRESS
	 RTS
*
BGAEXP0  MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 IN TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7)+,TCBAI(A0)     SAVE ACCESS INFORMATION
	 MOVE.L    (A7)+,TCBAA(A0)     SAVE ACCESS ADDRESS
	 MOVE.W    (A7)+,TCBIR(A0)     SAVE INSTRUCTION REGISTER
	 MOVE.W    (A7)+,TCBSR(A0)     SAVE SR IN TCB
	 MOVE.L    (A7)+,TCBPC(A0)     SAVE PC IN TCB
	 MOVE.W    #$0008,TCBVN(A0)    SAVE BUS ERROR VECTOR NUMBER
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 SF.B	   TCBHOLD(A0)	       SET HOLD FLAG TO FALSE
	 ST.B	   TCBERR(A0)	       SET ERROR FLAG TO TRUE
	 MOVE.W    #$2500,SR	       ALLOW PTM INTERRUPT
	 BRA	   BGEXEC	       GOTO RTEXEC
	 PAGE
**********************************************************************
*								     *
*	 EXCEPT1   ADDRESS ERROR EXCEPTION			     *
*								     *
**********************************************************************
EXCEPT1  EQU	   *
	 MOVE.W    #$2700,SR	       MASK ALL INTERRUPTS
	 TST.B	   SRTEXEC	       TEST RTEXEC FLAG
	 BEQ.S	   TSTBG1	       IF NOT GO AND TEST FOR B. G.
	 MOVE.L    SADDEX,-(A7)        PUSH REAL VECTOR ADDRESS
	 RTS			       GOTO ADDRESS ON STACK
*
TSTBG1	 TST.B	   SBGEXEC	       TEST BGEXEC FLAG
	 BNE.S	   BGAEXP1	       BRANCH IF TRUE
	 MOVE.L    SADDEX,-(A7)        PUSH REAL VECTOR ADDRESS
	 RTS
*
BGAEXP1  MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 IN TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7)+,TCBAI(A0)     SAVE ACCESS INFORMATION
	 MOVE.L    (A7)+,TCBAA(A0)     SAVE ACCESS ADDRESS
	 MOVE.W    (A7)+,TCBIR(A0)     SAVE INSTRUCTION REGISTER
	 MOVE.W    (A7)+,TCBSR(A0)     SAVE SR IN TCB
	 MOVE.L    (A7)+,TCBPC(A0)     SAVE PC IN TCB
	 MOVE.W    #$000C,TCBVN(A0)    SAVE ADDRESS ERROR VECTOR NUMBER
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 SF.B	   TCBHOLD(A0)	       SET HOLD FLAG TO FALSE
	 ST.B	   TCBERR(A0)	       SET ERROR FLAG TO TRUE
	 MOVE.W    #$2500,SR	       ALLOW PTM INTERRUPT
	 BRA	   BGEXEC	       GOTO RTEXEC
	 PAGE
**********************************************************************
*								     *
*	 EXCEPT2   DIVIDE BY ZERO EXCEPTION			     *
*								     *
**********************************************************************
EXCEPT2  EQU	   *
	 MOVE.W    #$2700,SR	       MASK ALL INTERRUPTS
	 TST.B	   SRTEXEC	       TEST RTEXEC FLAG
	 BEQ.S	   TSTBG2	       IF NOT GO AND TEST FOR B. G.
	 MOVE.L    SDZEX,-(A7)	       PUSH REAL VECTOR ADDRESS
	 RTS			       GOTO ADDRESS ON STACK
*
TSTBG2	 TST.B	   SBGEXEC	       TEST BGEXEC FLAG
	 BNE.S	   BGAEXP2	       BRANCH IF TRUE
	 MOVE.L    SDZEX,-(A7)	       PUSH REAL VECTOR ADDRESS
	 RTS
*
BGAEXP2  MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 IN TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7)+,TCBSR(A0)     SAVE SR IN TCB
	 MOVE.L    (A7)+,TCBPC(A0)     SAVE PC IN TCB
	 MOVE.W    #$0014,TCBVN(A0)    SAVE DIVIDE BY ZERO VECTOR NUMBER
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 SF.B	   TCBHOLD(A0)	       SET HOLD FLAG TO FALSE
	 ST.B	   TCBERR(A0)	       SET ERROR FLAG TO TRUE
	 MOVE.W    #$2500,SR	       ALLOW PTM INTERRUPT
	 BRA	   BGEXEC	       GOTO RTEXEC
	 PAGE
**********************************************************************
*								     *
*	 EXCEPT3   PRIV. VIOLATION EXCEPTION			     *
*								     *
**********************************************************************
EXCEPT3  EQU	   *
	 MOVE.W    #$2700,SR	       MASK ALL INTERRUPTS
	 TST.B	   SRTEXEC	       TEST RTEXEC FLAG
	 BEQ.S	   TSTBG3	       IF NOT GO AND TEST FOR B. G.
	 MOVE.L    SPVEX,-(A7)	       PUSH REAL VECTOR ADDRESS
	 RTS			       GOTO ADDRESS ON STACK
*
TSTBG3	 TST.B	   SBGEXEC	       TEST BGEXEC FLAG
	 BNE.S	   BGAEXP3	       BRANCH IF TRUE
	 MOVE.L    SPVEX,-(A7)	       PUSH REAL VECTOR ADDRESS
	 RTS
*
BGAEXP3  MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 IN TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7)+,TCBSR(A0)     SAVE SR IN TCB
	 MOVE.L    (A7)+,TCBPC(A0)     SAVE PC IN TCB
	 MOVE.W    #$0020,TCBVN(A0)    SAVE PRIV. VIOLATION VECTOR NUMBER
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 SF.B	   TCBHOLD(A0)	       SET HOLD FLAG TO FALSE
	 ST.B	   TCBERR(A0)	       SET ERROR FLAG TO TRUE
	 MOVE.W    #$2500,SR	       ALLOW PTM INTERRUPT
	 BRA	   BGEXEC	       GOTO RTEXEC
	 PAGE
**********************************************************************
*								     *
*	 RTMODCTL  REAL-TIME MODULE CONTROL (TRAP #6)		     *
*								     *
*		   INPUT:    D1 = MODULE NUMBER (0-RTNUMBER)	     *
*			     D2 = FLAG (00=ENABLE,FF=DISABLE)	     *
*								     *
**********************************************************************
RTMODCTL EQU	   *
	 MOVE.W    #$2700,SR	       MASK INTERRUPTS
	 MOVE.L    A0,-(A7)	       SAVE A0
	 CMP.L	   RTNUMBER,D1	       COMPARE TO MODULE NUMBER
	 BGT.S	   RTMODERR	       IF TOO LARGE BRANCH
	 LEA	   SBMODRUN,A0	       LOAD MODULE ENABLE LIST
	 ADD.L	   D1,A0	       ADD OFFSET
	 MOVE.B    D2,(A0)	       SET FLAG (TRUE OR FALSE)
RTMODERR MOVE.L    (A7)+,A0	       RESTORE A0
	 RTE
	 PAGE
**********************************************************************
*								     *
*	 RTMTC	   REAL-TIME MODULE TIMER CONTROL		     *
*								     *
*		   INPUT:    D0 = BYTE 00=CLEAR,FF=SET		     *
*								     *
**********************************************************************
RTMTC	 EQU	   *
	 MOVE.W    #$2700,SR	       MASK INTERRUPTS
	 TST.B	   D0		       TEST INPUT
	 SNE.B	   SBTIME	       SET TIMER CONTROL FLAG
	 RTE
	 PAGE
**********************************************************************
*								     *
*	 RTEXEC    REAL-TIME EXECUTIVE (PRIV ENTRY)		     *
*		   RUN BY 20HZ (50 MS) INTERRUPT		     *
*								     *
**********************************************************************
RTEXEC	 EQU	   *		       MODULE STARTS HERE
	 ST.B	   SRTEXEC	       ENABLE RTEXEC FLAG
	 TST.B	   SBFIRST	       TEST FIRST FRAME FLAG
	 BNE.S	   NOTFIRST	       SKIP INIT PART
	 ST.B	   SBFIRST	       SET FIRST FRAME FLAG
	 MOVE.L    #RTLIST,SMODADR     LOAD START OF JUMP LIST
	 MOVE.L    #SBMODRUN,SRUNADR   LOAD START OF ENABLE FLAG TABLE
	 MOVE.L    SMODADR,A1	       LOAD INTO A1
	 MOVE.L    SRUNADR,A2	       LOAD INTO A2
NOTFIRST EQU	   *
	 MOVE.B    (A1)+,D0	       LOAD FRAME MASK
	 MOVE.B    (A1)+,D1	       LOAD PRIV FLAG
	 MOVE.B    (A1),D2	       LOAD MODULE FORTRAN FLAG
	 ADDQ.L    #2,A1	       POINT TO MODULE ADDRESS
	 MOVE.B    (A2)+,D3	       LOAD RUN FLAG
	 MOVEM.L   A1/A2,-(A7)	       SAVE POINTERS
	 TST.B	   D3		       TEST RUN FLAG
	 BNE.S	   RTTRAP IF SET SKIP IT
	 MOVE.B    SCURMASK,D4	       LOAD CURRENT MASK
	 AND.B	   D0,D4	       RUN THIS MODULE THIS FRAME ?
	 TST.B	   D4		       TEST FOR ANY BITS SET
	 BEQ.S	   RTTRAP	       NOT THIS TIME
	 TST.B	   D1		       TEST FOR PRIV ENTRY
	 BNE.S	   SKIPAND	       SKIP AND IF TRUE
	 AND.W	   #$DFFF,SR	       TURN OFF PRIV BIT
SKIPAND  EQU	   *
	 MOVE.L    (A1),A1	       LOAD INDIRECT ADDRESS (ENTRY)
	 TST.B	   SBTIME	       TEST TIMER ENABLED
	 BEQ.S	   SKIPT	       SKIP IF FALSE
	 MOVE.L    STIMAD,A0	       LOAD ADDRESS OF TIMER
	 MOVE.W    #0,(A0)	       CLEAR TIMER
SKIPT	 EQU	   *
	 JMP	   (A1) 	       RUN REAL TIME MODULE
RTTRAP	 ST.B	   SBNOTIME	       SET NO TIME FLAG
TRAP0	 TRAP	   #0		       DO NOT RUN THIS TIME
	 PAGE
**********************************************************************
*								     *
*	 RTRET	   (TRAP #0) RETURN FOR REAL-TIME MODULES	     *
*								     *
**********************************************************************
RTRET	 EQU	   *
	 MOVE.W    #$2700,SR	       MASK ALL INTERUPTS
	 ADDQ.L    #6,A7	       GET RID OF SR & PC FROM TRAP #0
	 TST.B	   SBTIME	       TEST TIMER ENABLED
	 BEQ.S	   SKIPTIME	       SKIP CALCULATIONS IF FALSE
	 TST.B	   SBNOTIME	       TEST NO TIME FLAG
	 BNE.S	   SKIPTIME	       SKIP CALCULATIONS IF TRUE
	 CLR.L	   D0		       CLEAR D0
	 MOVE.L    STIMAD,A0	       LOAD ADDRESS OF TIMER
	 MOVE.W    (A0),D0	       GET TIME IN MICRO-SEC
	 ADD.L	   D0,TFRAME	       ADD TO FRAME TIME
	 MOVE.L    #TMODULE,A1	       LOAD ADDRESS
	 CLR.L	   D1		       CLEAR D1
	 MOVE.B    SMODULE,D1	       LOAD MODULE NUMBER
	 LSL.L	   #1,D1	       MULTIPLY BY 2
	 ADD.L	   D1,A1	       CALCULATE OFFSET
	 MOVE.W    D0,(A1)	       STORE MODULE TIME
	 MOVE.L    #TMODULEA,A1        LOAD ADDRESS
	 CLR.L	   D1		       CLEAR D1
	 MOVE.B    SMODULE,D1	       LOAD MODULE NUMBER
	 LSL.L	   #1,D1	       MULTIPLY BY 2
	 ADD.L	   D1,A1	       CALCULATE OFFSET
	 MOVE.W    (A1),D1	       LOAD LAST VALUE
	 ADD.W	   D0,D1	       ADD TIMES
	 LSR.W	   #1,D1	       DIVIDE BY 2
	 MOVE.W    D1,(A1)	       STORE NEW AVERAGE
	 MOVE.L    #TMODULEW,A1        LOAD ADDRESS
	 CLR.L	   D1		       CLEAR D1
	 MOVE.B    SMODULE,D1	       LOAD MODULE NUMBER
	 LSL.L	   #1,D1	       MULTIPLY BY 2
	 ADD.L	   D1,A1	       CACULATE OFFSET
	 MOVE.W    (A1),D1	       LOAD LAST VALUE
	 CMP.W	   D1,D0	       COMPARE NEW WITH OLD VALUE
	 BLE.S	   SKIPTIME	       IF LESS OR EQUAL QUIT
	 MOVE.W    D0,(A1)	       SAVE THE NEW GREATER VALUE
SKIPTIME SF.B	   SBNOTIME	       CLEAR NO TIME FLAG
	 MOVEM.L   (A7)+,A1/A2	       RESTORE POINTERS
	 ADDQ.L    #4,A1	       INCREMENT JUMP LIST POINTER
	 ADDQ.B    #1,SMODULE	       INCREMENT MODULE NUMBER
	 MOVE.W    #$2400,SR	       ALLOW PTM INTERRUPT
	 BRA	   NOTFIRST	       GO DO NEXT MODULE
	 PAGE
**********************************************************************
*								     *
*	 RTEND	   LAST MODULE OF EVER FRAME (PRIV ENTRY) 20HZ	     *
*		   RUN AS LAST MODULE IN LOAD			     *
*								     *
**********************************************************************
RTEND	 EQU	   *		       LAST MODULE OF EACH FRAME
	 MOVE.W    #$2700,SR	       MASK ALL INTERRUPTS
	 ADD	   #8,A7	       CORRECT STACK (A1-A2)
	 MOVE.L    TFRAMEA,D0	       LOAD AVVERAGE FRAME TIME
	 ADD.L	   TFRAME,D0	       LOAD LAST FRAME TIME
	 LSR.L	   #1,D0	       DIVIDE BY 2
	 MOVE.L    D0,TFRAMEA	       SAVE NEW AVERAGE FOR TOTAL FRAME TIME
	 MOVE.L    TFRAMEW,D1	       LOAD WORST CASE TIME
	 MOVE.L    TFRAME,D0	       LOAD ACTUAL
	 CMP.L	   D1,D0	       COMPARE TIMES
	 BLE.S	   SKIPTW	       BRANCH IF LESS OR EQUAL TO WORST CASE
	 MOVE.L    D0,TFRAMEW	       STORE NEW WORST CASE
SKIPTW	 CLR.L	   TFRAME	       CLEAR TOTAL FRAME TIME
	 MOVE.B    SFRAME,D0	       LOAD FRAME NUMBER
	 ADDQ.B    #1,D0	       INCREMENT FRAME
	 CMPI.B    #8,D0	       NEXT CYCLE ?
	 BEQ.S	   NEWCYCLE	       IF 8 THEN GOTO NEWCYCLE
	 MOVE.B    D0,SFRAME	       SAVE FRAME NUMBER BACK
	 LSR.W	   SCURMASK	       MOVE BIT ONE TO THE RIGHT
	 CLR.B	   SMODULE	       SET MODULE NUMBER TO ZERO
	 CLR.B	   SRTEXEC	       CLEAR RTEXEC FLAG
	 CLR.B	   SBFIRST	       CLEAR FIRST FRAME FLAG
	 BRA.S	   BGEXEC	       GO TO BACK-GROUND EXEC
NEWCYCLE EQU	   *
	 CLR.B	   SFRAME	       SET FRAME NUMBER TO ZERO
	 ADDQ.L    #1,SCYCLE	       INCREMENT CYCLE
	 MOVE.W    #$8000,SCURMASK     SET FRAME MASK TO FIRST FRAME
	 CLR.B	   SBFIRST	       CLEAR FIRST FRAME FLAG
	 CLR.B	   SMODULE	       SET MODULE NUMBER TO ZERO
	 CLR.B	   SRTEXEC	       CLEAR RTEXEC FLAG
	 BRA.S	   BGEXEC	       GO TO BACK-GROUND EXEC
	 NOP			       MAKE A GAP
	 PAGE
**********************************************************************
*								     *
*	 BGEXEC    BACK-GROUND EXECUTIVE MODULE 		     *
*		   RUN AT END OF EACH FRAME			     *
*								     *
**********************************************************************
BGEXEC	 EQU	   *		       BACK-GROUND EXEC
	 CLR.W	   STCBID	       CLEAR ACTIVE TASK ID
	 MOVE.L    STCB,A1	       LOAD ADDRESS OF ACTIVE TCB
	 MOVE.L    TCBLINK(A1),A1      POINT TO NEXT TASK
BGNXT	 TST.B	   TCBERR(A1)	       TEST ERROR FLAG
	 BNE.S	   ERRTSK	       BRANCH IF TRUE
	 TST.B	   TCBRUN(A1)	       TEST RUN FLAG
	 BNE.S	   RUNTSK	       BRANCH IF TRUE
	 TST.B	   TCBHOLD(A1)	       TEST HOLD FLAG
	 BNE.S	   HLDTSK	       BRANCH IF TRUE
NXTSK	 MOVE.L    TCBLINK(A1),A1      NEXT TASK LINK
	 MOVE.L    A1,STCB	       SAVE LINK
	 BRA.S	   BGNXT	       TRY NEXT ONE
RUNTSK	 MOVE.L    TCBSS(A1),A2        LOAD STACK SEGMENT ADDRESS
	 MOVE.L    A2,USP	       LOAD USP
	 MOVE.W    TCBID(A1),STCBID    LOAD TASK ID
	 MOVE.L    A1,STCB	       SAVE ADDRESS OF ACTIVE TCB
	 MOVE.L    TCBDS(A1),A0        LOAD START OF DATA SEGMENT
	 MOVE.L    TCBENTRY(A1),-(A7)  LOAD ENTRY PC ON STACK
	 MOVE.W    #$0000,-(A7)        LOAD INITIAL SR ON STACK
	 ST.B	   SBGEXEC	       SET BACK-GROUND FLAG
	 RTE			       JUMP TO BACK-GROUND MODULE
HLDTSK	 MOVE.L    TCBUSP(A1),A2       LOAD STACK POINTER
	 MOVE.L    A2,USP	       LOAD USP
	 MOVE.W    TCBID(A1),STCBID    LOAD TASK ID
	 MOVE.L    A1,STCB	       SAVE ADDRESS OF ACTIVE TCB
	 MOVE.L    TCBPC(A1),-(A7)     LOAD PC ON STACK
	 MOVE.W    TCBSR(A1),-(A7)     LOAD SR ON STACK
	 MOVEM.L   TCBREGS(A1),D0-D7/A0-A6	 RESTORE REGISTERS
	 ST.B	   SBGEXEC	       SET BACK-GROUND FLAG
	 RTE			       JUMP TO BACK-GROUND MODULE
ERRTSK	 TST.B	   TCBEX(A1)	       TEST EXCEPTION ENTRY FLAG
	 BEQ.S	   NXTSK	       BRANCH IF FALSE
	 SF.B	   TCBERR(A1)	       CLEAR ERROR FLAG
	 ST.B	   TCBRUN(A1)	       SET RUN FLAG
	 MOVE.L    TCBSS(A1),A2        LOAD STACK SEGMENT ADDRESS
	 MOVE.L    A2,USP	       LOAD USP
	 MOVE.W    TCBID(A1),STCBID    LOAD TASK ID
	 MOVE.L    A1,STCB	       SAVE ADDRESS OF ACTIVE TCB
	 MOVE.L    TCBDS(A1),A0        LOAD START OF DATA SEGMENT
	 MOVE.W    TCBVN(A1),D0        LOAD ERROR VECTOR NUMBER
	 MOVE.L    TCBEXEP(A1),-(A7)   LOAD EXCEPTION ENTRY ON STACK
	 MOVE.W    #$0000,-(A7)        LOAD INITIAL SR ON STACK
	 ST.B	   SBGEXEC	       SET BACK-GROUND FLAG
	 RTE			       JUMP TO BACK-GROUND MODULE
	 PAGE
**********************************************************************
*								     *
*	 BGHOLD    BACK-GROUND HOLD (TRAP #1)			     *
*								     *
**********************************************************************
BGHOLD	 EQU	   *
	 MOVE	   #$2700,SR	       MASK ALL INTERUPTS
	 MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 IN TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7)+,TCBSR(A0)     SAVE SR IN TCB
	 MOVE.L    (A7)+,TCBPC(A0)     SAVE PC IN TCB
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 ST.B	   TCBHOLD(A0)	       SET HOLD FLAG TO TRUE
	 BRA	   BGEXEC	       GO BACK TO BGEXEC
**********************************************************************
*								     *
*	 BGWAIT    BACK-GROUND WAIT (TRAP #2)			     *
*								     *
**********************************************************************
BGWAIT	 EQU	   *
	 MOVE	   #$2700,SR	       MASK ALL INTERUPTS
	 MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB,A0	       LOAD ADDRESS OF ACTIVE TCB
	 MOVEM.L   D0-D7/A0-A6,TCBREGS(A0)	 SAVE REGISTERS IN TCB
	 MOVE.L    STEMP,TCBREGS+32(A0) 	 SAVE A0 IN TCB
	 MOVE.L    USP,A1	       LOAD USP
	 MOVE.L    A1,TCBUSP(A0)       SAVE USP IN TCB
	 MOVE.W    (A7)+,TCBSR(A0)     SAVE SR IN TCB
	 MOVE.L    (A7)+,TCBPC(A0)     SAVE PC IN TCB
	 SF.B	   TCBRUN(A0)	       SET RUN FLAG TO FALSE
	 ST.B	   TCBWAIT(A0)	       SET WAIT FLAG TO TRUE
	 BRA	   BGEXEC	       GO BACK TO BGEXEC
	 PAGE
**********************************************************************
*								     *
*	 BGTERM    BACK-GROUND TERMINATE (TRAP #3)		     *
*								     *
**********************************************************************
BGTERM	 EQU	   *
	 MOVE	   #$2700,SR	       MASK ALL INTERUPTS
	 MOVE.L    STCB,A1	       LOAD ADDRESS OF ACTIVE TCB
	 MOVE.W    #$0000,TCBSR(A1)    SAVE SR IN TCB
	 MOVE.L    TCBENTRY(A1),TCBPC(A1)	 SAVE ENTRY AT PC
	 MOVE.L    TCBSS(A1),TCBUSP(A1) 	 SAVE STACK SEGMENT AT USP
	 SF.B	   TCBRUN(A1)	       SET RUN FLAG TO FALSE
	 SF.B	   TCBHOLD(A1)	       SET HOLD FLAG TO FALSE
	 BRA	   BGEXEC	       GO BACK TO BGEXEC
**********************************************************************
*								     *
*	 BGRSUM    BACK-GROUND RESUME (TASK NUMBER IN D0)	     *
*		   TRAP #4					     *
*								     *
**********************************************************************
BGRSUM	 EQU	   *
	 MOVE	   #$2700,SR	       MASK ALL INTERRUPTS
	 CMP	   #1,D0	       COMPARE TO LOWEST VALUE
	 BLT.S	   EXRSUM	       EXIT IF LESS THEN ZERO
	 CMP	   STCBNUM,D0	       COMPARE TO HIGHEST VALID TASK
	 BGT.S	   EXRSUM	       EXIT IF GREATER THAN TASKNUM
	 SUBQ.L    #1,D0	       ADJUST FOR OFFSET
	 MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB1,A0	       LOAD ADDRESS OF FIRST TCB IN CHAIN
RSUMLP	 MOVE.L    TCBLINK(A0),A0      GET NEXT LINK
	 DBRA	   D0,RSUMLP	       LOOP UNTIL A0-> RIGHT TCB
	 SF.B	   TCBHOLD(A0)	       CLEAR HOLD FLAG
	 MOVE.L    STEMP,A0	       RESTORE A0
EXRSUM	 RTE			       RETURN
	 PAGE
~~ ...M68K D2.0C  3/12/85   ...Run on Dec 4, 2025  13:47:24
	 END
 VALID TASK
	 BGT.S	   EXRSUM	       EXIT IF GREATER THAN TASKNUM
	 SUBQ.L    #1,D0	       ADJUST FOR OFFSET
	 MOVE.L    A0,STEMP	       SAVE A0
	 MOVE.L    STCB1,A0	       LOAD ADDRESS OF FIRST TCB IN CHAIN
RSUMLP	 MOVE.L    TCBLINK(A0),A0      GET NEXT LINK
	 DBRA	   D0,RSUMLP	       LOOP UNTIL A0-> RIGHT TCB
	 SF.B	   TCBHOLD(A0)	       CLEAR HOLD FLAG
	 M